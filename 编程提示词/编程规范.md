**团队代码编写说明（清晰 · 无歧义 · 可执行）**

---

## 一、代码需要有高可读性

### ✅ 做法

- 函数只做一件事，逻辑不要堆在一起。
    
- 命名直白，不省字：`fetch_customer_data()` 比 `fchCstD()` 强太多。
    
- 文件命名用小写加下划线：`user_manager.py`。
    

### 💡 原因

好代码不需要猜。任何人打开文件，都能十秒明白大概干啥。

---

## 二、让代码逻辑结构线性、可预测

逻辑结构应简洁、可顺序理解，避免深层嵌套和条件套娃
### ✅ 做法

- 避免三层以上嵌套。
    
- 复杂判断提炼成函数或变量：
    
    `if is_valid_user(user) and has_permission(user):     process_order()`
    
- 使用早返回（early return），避免“大 if 套娃”。
    

### 💡 原因

清晰的逻辑结构让更容易让人理解。

---

## 三、代码即文档

### ✅ 做法

- 每个函数写上用途说明和参数说明：
    
    `def calculate_discount(price: float, rate: float) -> float:     """计算折扣后的价格"""     return price * (1 - rate)`
    
- 模块开头写用途注释。
    
- 统一使用 docstring，不用乱写行内注释。
    

### 💡 原因

当代码能自我解释，就不需要额外的解释。

---

## 四、可测试、可复用

### ✅ 做法

- 函数不要依赖全局变量。
    
- 避免副作用（print、写文件、调用外部 API）。
    
- 把输入输出清楚定义，逻辑通过返回值传递。
    
- 写单元测试，测试独立可跑。
    

### 💡 原因

可测试的代码就是可维护的代码，能复用，能放心改。

---

## 五、让错误暴露早、提示准

**核心原则**：所有异常应尽早抛出，并包含完整上下文信息。

### ✅ 做法

- 所有输入先校验：
    
    `if price < 0:     raise ValueError("价格不能为负")`
    
- 日志要清楚上下文：
    
    `logger.error(f"订单创建失败: user={user.id}, reason={e}")`
    

### 💡 原因

早发现错误比晚调试快十倍。  
日志是救命索引，不是流水账。

---

## 六、一致性比完美更重要

### ✅ 做法

- 全项目统一风格：命名、格式、注释风格一致。
    
- 强制使用格式化工具：
    
    - 格式化：`ruff`
        
    - 代码检查：`ruff`
        
    - 类型检查：`mypy` 或 `pyright`
        
- 所有文件统一编码、缩进、导入顺序。
    

### 💡 原因

团队协作靠一致性。看起来像一个人写的代码，效率最高。

---

## 七、能删的才是好代码

模块应低耦合、高内聚，能被独立删除、替换或复用。
### ✅ 做法

- 模块独立、依赖最小。
    
- 不写死路径、密钥、配置。
    
- 一切可变信息放配置文件或环境变量。
    
- 永远假设未来要重构或替换。
    
### 💡 原因

好代码不是“完美不能动”，而是“随时能删、能换、能扩”。

## 八、数据结构是核心

> "烂程序员关心代码，好程序员关心数据结构和它们之间的关系。"

### ✅ 做法

- **优先设计数据结构**：在写任何逻辑代码之前，先花时间想清楚你要处理的数据应该是什么样子。
    
- **让数据结构简单、一致**：用最直接、最符合现实逻辑的方式组织数据。避免为了所谓的“效率”而设计出扭曲、难以理解的结构。
    
- **代码应该服务于数据**：写代码来操作你设计好的数据结构，而不是反过来，为了迁就蹩脚的逻辑而拼凑数据。
    

### 💡 原因

**代码的复杂性，90%来源于糟糕的数据结构。** 当数据结构清晰、合理时，你会发现对应的逻辑代码写起来自然而然，简单明了。把数据搞对了，代码想烂都难。

## 十、接口是契约，不是摆设

> "Talk is cheap. Show me the code." (引申义：接口定义了你能做什么，代码展示了你是怎么做的。别只说，把接口定义清楚。)

### ✅ 做法

- **明确定义输入和输出**：一个函数的接口（参数、返回值、可能抛出的异常）必须像法律条文一样清晰、稳定。
    
- **隐藏实现细节**：调用者只关心“你能做什么”（接口），而不应该关心“你怎么做”（实现）。不要暴露内部状态或逻辑。
    
- **依赖抽象，而非具体**：函数和模块之间应该通过稳定的接口进行交互，而不是依赖于对方的具体实现。
    

### 💡 原因

**稳定的接口是系统可维护、可扩展的基石。** 只要接口这个“契约”不变，你就可以随意重构、优化甚至完全替换掉接口背后的实现，而不会影响到系统的其他任何部分。这给了你修复和改进的巨大自由。